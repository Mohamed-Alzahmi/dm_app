# -*- coding: utf-8 -*-
"""T1_2022_OCR_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tK3Pos8IevW8GBhbbjVJqFXghFXxGPKa
"""

import numpy as np
import pandas as pd
import difflib
import cv2
import matplotlib.pyplot as plt

from skimage.filters import threshold_local
from PIL import Image

import re
import cv2
import pytesseract
import numpy as np
import matplotlib.pyplot as plt

from skimage.filters import threshold_local
from PIL import Image
from pytesseract import Output
from prettytable import PrettyTable

import sys
#from unidecode import unidecode

def opencv_resize(image, ratio):
    width = int(image.shape[1] * ratio)
    height = int(image.shape[0] * ratio)
    dim = (width, height)
    return cv2.resize(image, dim, interpolation = cv2.INTER_AREA)

def approximate_contour(contour):
    peri = cv2.arcLength(contour, True)
    return cv2.approxPolyDP(contour, 0.032 * peri, True)

def get_receipt_contour(contours):    
    # loop over the contours
    approx_list = []   
    for c in contours:  
        approx = approximate_contour(c) 
        # if our approximated contour has four points, we can assume it is receipt's rectangle
        if len(approx) >=1:
            try:
                approx_list.append((len(approx),approx,  cv2.contourArea(c)))  
            except:
                continue
    if len(approx_list) == 0:
        return []
    # find rect
    rect_approx = [item[1] for item in approx_list if (item[0] == 4) and (item[1].size %4 == 0)]
    if len(rect_approx) > 0:
        return rect_approx
        #rect_approx_area = max(rect_approx,key=lambda item:item[2])
        #return rect_approx_area # (rect_approx_area)[1]  
    # else not rect  
    # to-do 
    #max_approx = max(approx_list,key=lambda item:item[0])  
    return []
    #otherwise            
    

def contour_to_rect(contour):
    pts = contour.reshape(4, 2)
    rect = np.zeros((4, 2), dtype = "float32")
    # top-left point has the smallest sum
    # bottom-right has the largest sum
    s = pts.sum(axis = 1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]
    # compute the difference between the points:
    # the top-right will have the minumum difference 
    # the bottom-left will have the maximum difference
    diff = np.diff(pts, axis = 1)
    rect[1] = pts[np.argmin(diff)]
    rect[3] = pts[np.argmax(diff)]
    return rect

def wrap_perspective(img, rect):
    # unpack rectangle points: top left, top right, bottom right, bottom left
    (tl, tr, br, bl) = rect
    # compute the width of the new image
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    # compute the height of the new image
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    # take the maximum of the width and height values to reach
    # our final dimensions
    maxWidth = max(int(widthA), int(widthB))
    maxHeight = max(int(heightA), int(heightB))
    # destination points which will be used to map the screen to a "scanned" view
    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype = "float32")
    # calculate the perspective transform matrix
    M = cv2.getPerspectiveTransform(rect, dst)
    # warp the perspective to grab the screen
    return cv2.warpPerspective(img, M, (maxWidth, maxHeight))

def find_between( s, first, last ):
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""

def find_between_r( s, first, last ):
    try:
        start = s.rindex( first ) + len( first )
        end = s.rindex( last, start )
        return s[start:end]
    except ValueError:
        return ""

def bw_scanner(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    T = threshold_local(gray, 21, offset = 5, method = "gaussian")
    return (gray > T).astype("uint8") * 255

# pre_processing 
def image_pre_processing(image): 
    # Convert to grayscale for further processing
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # Get rid of noise with Gaussian Blur filter
    blurred = cv2.GaussianBlur(gray, (3, 3), 0) 
    threshold = cv2.adaptiveThreshold(blurred, 255,cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 21, 10)
    #threshold = cv2.adaptiveThreshold(threshold, 255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 21, 10)
    #ret, threshold = cv2.threshold(blurred,127, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) 
    return threshold

# Sample file out of the dataset
PyTesLoc = sys.argv[1]
FileNameLoc = sys.argv[2]
UserID = '1234' #sys.argv[3]

#load pytesseract
pytesseract.pytesseract.tesseract_cmd = PyTesLoc
file_name = FileNameLoc

image = cv2.imread(file_name)
# Downscale image as finding receipt contour is more efficient on a small image
resize_ratio = 500 / image.shape[0]
original = image.copy()  
image_pre_processed = image_pre_processing(image) 
# save image
output_processed = Image.fromarray(image_pre_processed)
output_processed.save('./uploads/result_processed.png')   
extracted_text = pytesseract.image_to_string(image_pre_processed)
print (extracted_text.encode(sys.stdout.encoding, errors='replace').decode(sys.stdout.encoding))
# contours, hierarchy = cv2.findContours(threshold, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
# len_countrs  = min(len(contours), 10)
# largest_contours = sorted(contours, key = cv2.contourArea, reverse = True)[:len_countrs] 
# receipt_contour = get_receipt_contour(largest_contours) 
# for c in receipt_contour:
#     print(cv2.contourArea(c)) 
 
# image_copy = original.copy()
# output = cv2.drawContours(image_copy, receipt_contour, -1, (0, 255, 0), 2)
# output = Image.fromarray(image_copy)
# output.save('./uploads/result_Contours.png')  

# scanned = wrap_perspective(output, contour_to_rect(receipt_contour[1]))
# #already gray
# scanned = bw_scanner(scanned)
# output = Image.fromarray(scanned)
# output.save('./uploads/result_scanned.png')  
# extracted_text = pytesseract.image_to_string(output)
# extracted_text = extracted_text.encode(sys.stdout.encoding, errors='replace')
# print(extracted_text)

#  
# By default OpenCV stores images in BGR format and since pytesseract assumes RGB format,
# we need to convert from BGR to RGB format/mode:
# image = cv2.imread('./uploads/result_Contours.png')
# img_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
#print(pytesseract.image_to_string(img_rgb))
# OR
# img_rgb = Image.frombytes('RGB', image.shape[:2], image, 'raw', 'BGR', 0, 0)
# print (pytesseract.image_to_string(img_rgb).encode(sys.stdout.encoding, errors='replace'))
#print(pytesseract.image_to_string(img_rgb))
#print("Process lines, file_name command_line %s\n"% pytesseract.image_to_string(img_rgb).encode('utf-8'))  




#print(extracted_text)
# Supermarket= "None"
# listword1 = ['woolworth', 'WOOLWORTH', 'Woolworth']
# listword2 = ['coles', 'COLES', 'Coles']
# if any(re.search(r'\b{}\b'.format(re.escape(word)), extracted_text) for word in listword1):
#     Supermarket = 'Woolworths'

# print(Supermarket)

# elif any(re.search(r'\b{}\b'.format(re.escape(word)), extracted_text) for word in listword2):
#     Supermarket = 'Coles'
# else:
#     Supermarket = ''
      
# print(Supermarket)

# from datetime import datetime

# match = re.search(r'\d{2}/\d{2}/\d{4}', extracted_text)
# date = datetime.strptime(match.group(), '%d/%m/%Y').date()
# print(date)


# #Store
# StoreN = find_between( extracted_text, "Store: ", ";" )
# print(StoreN)

# #Receipt ID
# Receipt_ID = find_between( extracted_text, "Receipt: ", "Date:" )
# print(Receipt_ID)

# #Product descriptions and prices
# desc = find_between( extracted_text, "scription ", "EFT" )

# #desc = find_between( desc, ";","Total" )
# print(desc)

# #extracting grand total
# def find_amounts(text):
#     amounts = re.findall(r'\d+\.\d{2}\b', text)
#     floats = [float(amount) for amount in amounts]
#     unique = list(dict.fromkeys(floats))
#     return unique

# amounts = find_amounts(extracted_text)
# amounts

# max(amounts)

# #Lines to excluse on the receipt
# exclusion_list = ["bank", "total", "promo", "vat", "change", "recyclable"]

# #Words to ommit
# remove_list = ["vit", "etc"]

# #Extract letters and numbers regex
# regex_line = []
# for line in desc.splitlines():
#     if re.search(r".[0-9]|[0-9]*\.[0-9]|[0-9]*\,[0-9]", line):
#         regex_line.append(line)
# print(regex_line)

# #Apply exclusion list
# food_item = []
# for eachLine in regex_line:
#     found = False
#     for exclude in exclusion_list:
#         if exclude in eachLine.lower():
#             found = True
        
#     if found == False:
#         food_item.append(eachLine)
# print(food_item)

# #Word ommit
# new_food_item_list = []
# for item in food_item:
#     for subToRemove in remove_list:
#         item = item.replace(subToRemove, "")
#         item = item.replace(subToRemove.upper(), "")
#     new_food_item_list.append(item)
# print(new_food_item_list)

# #Food item cost regex
# food_item_cost = []
# for line in new_food_item_list:
#     line = line.replace(",", ".")
#     cost = re.findall('\d*\.?\d+|\d*\,?\d+|',line)
    
#     for possibleCost in cost:
#         if "." in possibleCost:
#             food_item_cost.append(possibleCost)
# print(new_food_item_list)

# #Remove cost price from food item
# count = 0
# only_food_items = []
# for item in new_food_item_list:
#     only_alpha = ""
#     for char in item:
#         if char.isalpha() or char.isspace():
#             only_alpha += char
            
#     only_alpha = re.sub(r'(?:^| )\w(?:$| )', ' ', only_alpha).strip()
#     only_food_items.append(only_alpha)
# print(only_food_items)

# #Removes 2 letter words from food item
# #No core food item has two letters (Most cases)
# food = []
# for item in only_food_items:
#     # getting splits
#     temp = item.split()

#     # omitting K lengths
#     res = [ele for ele in temp if len(ele) != 2]

#     # joining result
#     res = ' '.join(res)
    
#     food.append(res)
# print(food)

# unwanted = {"EACH","GRAM","NET","eer"}
 
# food = [ele for ele in food if ele not in unwanted]
# food = [x for x in food if "BETTER BAG" not in x]

# print(food)

# #Tabulate Food Item and Cost
# t = PrettyTable(['Food Item', 'Cost'])

# for counter in range (0,len(food)):
#     t.add_row([food[counter], food_item_cost[counter]])
# print(t)

# import pandas as pd
# df = pd.DataFrame(food, columns=['food'])
# df1 = pd.DataFrame(food_item_cost, columns=['Cost'])

# df2 = pd.concat([df, df1], axis=1)
# df2['Receipt_ID'] = Receipt_ID
# df2['Supermarket'] = Supermarket
# df2['date'] = date
# df2['Store'] = StoreN
# df2['Processed'] = 0
# df2.dropna(inplace=True)
# df2['UserID'] = UserID
# df2['StoreID'] = ''
# df2.head(15)

# import mysql.connector
# import pymysql
# from sqlalchemy import create_engine

# #engine = create_engine('mysql+mysqlconnector://{user}:{password}@{host}:{port}/{database}', echo=False)
# con = create_engine('mysql+pymysql://discountmateuser:DMPassword$@127.0.0.1/discountmate')

# store = pd.read_sql('SELECT * FROM shops', con=con)
# store.head(10)

# StoreID = ''
# # if store['address'].str.contains(StoreN).any():
# #     StoreID = store.loc[store['address'] == StoreN, 'id'].iloc[0]  
    
# print(StoreID)

# max_value = ''
# if StoreID == '':
#   column = store["id"]
#   max_value = column.max()
#   StoreID = max_value + 1
#   data = [{'id':StoreID,'name':Supermarket,'address':StoreN,'postcode':'2000'}]
#   store = store.append(data,ignore_index=True,sort=False)

# df2['StoreID'] = StoreID

# #store.to_sql("shops",con=con,index=False,if_exists="replace")

# df2.head(16)

# df2.to_sql("OCRTable",con=con,index=False,if_exists="append")

